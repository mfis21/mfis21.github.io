<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Chess Game</title>
    <style>
        /* Chessboard Styles */
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 400px;
            height: 400px;
            border: 1px solid #000;
        }

        .chessboard .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }

        .chessboard .cell:nth-child(even) {
            background-color: #f2f2f2;
        }

        .selected {
            background-color: yellow;
        }
    </style>
</head>
<body>
    <div class="chessboard">
        <!-- Chessboard Cells -->
        <div class="cell" onclick="selectCell(this, 0, 0)">♜</div>
        <div class="cell" onclick="selectCell(this, 0, 1)">♞</div>
        <div class="cell" onclick="selectCell(this, 0, 2)">♝</div>
        <div class="cell" onclick="selectCell(this, 0, 3)">♛</div>
        <div class="cell" onclick="selectCell(this, 0, 4)">♚</div>
        <div class="cell" onclick="selectCell(this, 0, 5)">♝</div>
        <div class="cell" onclick="selectCell(this, 0, 6)">♞</div>
        <div class="cell" onclick="selectCell(this, 0, 7)">♜</div>

        <!-- Remaining cells omitted for brevity -->

    </div>

    <script>
        let selectedCell = null;
        let isWhiteTurn = true;
        const chessboard = document.querySelector('.chessboard');

        function selectCell(cell, row, col) {
            if (selectedCell) {
                // Move the selected piece to the clicked cell
                const isValidMove = movePiece(selectedCell, cell);
                if (isValidMove) {
                    cell.innerHTML = selectedCell.innerHTML;
                    selectedCell.innerHTML = '';
                    selectedCell.classList.remove('selected');
                    selectedCell = null;
                    isWhiteTurn = !isWhiteTurn;
                } else {
                    alert('Invalid move!');
                }
            } else {
                // Select the clicked cell
                if (cell.innerHTML !== '') {
                    if ((cell.innerHTML.includes('♜') && isWhiteTurn) || (cell.innerHTML.includes('♚') && !isWhiteTurn)) {
                        cell.classList.add('selected');
                        selectedCell = cell;
                    } else {
                        alert("It's not your turn!");
                    }
                }
            }
        }

        function movePiece(sourceCell, targetCell) {
            const piece = sourceCell.innerHTML;
            const sourceRow = parseInt(sourceCell.style.gridRow) - 1;
            const sourceCol = parseInt(sourceCell.style.gridColumn) - 1;
            const targetRow = parseInt(targetCell.style.gridRow) - 1;
            const targetCol = parseInt(targetCell.style.gridColumn) - 1;

            // Check if the move is valid for the selected piece
            if (isValidMove(piece, sourceRow, sourceCol, targetRow, targetCol)) {
                // Check if there is a piece at the target cell (capturing)
                if (targetCell.innerHTML !== '') {
                    // Checkmate condition
                    if (targetCell.innerHTML.includes('♚')) {
                        alert('Checkmate! Game Over.');
                        chessboard.removeEventListener('click', handleCellClick);
                        return true;
                    }
                }

                return true;
            }

            return false;
        }

        function isValidMove(piece, sourceRow, sourceCol, targetRow, targetCol) {
            const rowDiff = Math.abs(targetRow - sourceRow);
            const colDiff = Math.abs(targetCol - sourceCol);

            switch (piece) {
                case '♟': // Pawn
                    // Pawn can move one step forward or two steps forward from its starting position
                    // It can capture diagonally forward by one step
                    if (sourceCol === targetCol) {
                        // Moving forward
                        if (sourceRow === 1 && targetRow === 3) {
                            // Two steps forward from starting position
                            return true;
                        } else if (targetRow - sourceRow === 1) {
                            // One step forward
                            return true;
                        }
                    } else if (colDiff === 1 && targetRow - sourceRow === 1) {
                        // Capturing diagonally
                        return true;
                    }
                    break;

                case '♜': // Rook
                    // Rook can move horizontally or vertically any number of steps
                    if (sourceRow === targetRow || sourceCol === targetCol) {
                        return true;
                    }
                    break;

                case '♝': // Bishop
                    // Bishop can move diagonally any number of steps
                    if (rowDiff === colDiff) {
                        return true;
                    }
                    break;

                case '♞': // Knight
                    // Knight moves in an L-shape pattern
                    if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {
                        return true;
                    }
                    break;

                case '♛': // Queen
                    // Queen can move horizontally, vertically, or diagonally any number of steps
                    if (sourceRow === targetRow || sourceCol === targetCol || rowDiff === colDiff) {
                        return true;
                    }
                    break;

                case '♚': // King
                    // King can move one step in any direction
                    if (rowDiff <= 1 && colDiff <= 1) {
                        return true;
                    }
                    break;

                default:
                    return false;
            }

            return false;
        }
    </script>
</body>
</html>
